// Generated by CoffeeScript 1.6.1
(function() {
  var Capture, HTTPParser, Packet, Stream, Transaction, packet_begin,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Packet = window.Packet;

  HTTPParser = window.HTTPParser;

  packet_begin = function(packet, bandwidth) {
    return packet.timestamp - packet.size / bandwidth;
  };

  window.Capture = Capture = (function() {

    function Capture(pcap) {
      var begin, tcp_tracker,
        _this = this;
      this.capture = this;
      this.pcap = new Packet.views.PcapFile(pcap);
      this.streams = [];
      this.transactions = [];
      this.packets = [];
      begin = void 0;
      tcp_tracker = Packet.stream.tcp();
      tcp_tracker.on('connection', function(ab, ba, connection) {
        var stream;
        stream = new Stream(_this, ab, ba, connection);
        return stream.id = _this.streams.push(stream) - 1;
      });
      try {
        this.pcap.packets.forEach(function(packet) {
          packet.id = _this.packets.push(packet) - 1;
          packet.timestamp = packet.ts_sec + packet.ts_usec / 1000000;
          if (begin == null) {
            begin = packet.timestamp;
          }
          packet.relative_timestamp = packet.timestamp - begin;
          return tcp_tracker.write(packet);
        });
        tcp_tracker.end();
        if (this.pcap.packets.length === 0) {
          throw 'No packets in file';
        }
      } catch (e) {
        alert('File parsing error. Make sure the file is in libpcap (and not pcapng) format.');
        throw e;
      }
    }

    Capture.prototype.filter = function(client, server) {
      var filtered;
      filtered = Object.create(Capture.prototype);
      filtered.capture = this.capture;
      filtered.pcap = this.pcap;
      filtered.streams = this.streams.filter(function(stream) {
        return (!client || stream.src.ip === client) && (!server || stream.dst.address === server);
      });
      filtered.transactions = this.transactions.filter(function(transaction) {
        var _ref;
        return _ref = transaction.stream, __indexOf.call(filtered.streams, _ref) >= 0;
      });
      filtered.packets = this.packets.filter(function(packet) {
        var _ref;
        return _ref = packet.transaction, __indexOf.call(filtered.transactions, _ref) >= 0;
      });
      return filtered;
    };

    Capture.prototype.clients = function() {
      var stream;
      return _.uniq((function() {
        var _i, _len, _ref, _results;
        _ref = this.streams;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stream = _ref[_i];
          if (stream.transactions.length !== 0) {
            _results.push(stream.src.ip);
          }
        }
        return _results;
      }).call(this));
    };

    Capture.prototype.servers = function() {
      var stream;
      return _.uniq((function() {
        var _i, _len, _ref, _results;
        _ref = this.streams;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stream = _ref[_i];
          if (stream.transactions.length !== 0) {
            _results.push(stream.dst.address);
          }
        }
        return _results;
      }).call(this));
    };

    Capture.prototype.packets_in = function() {
      return this.packets.filter(function(packet) {
        return __indexOf.call(packet.transaction.packets_in, packet) >= 0;
      });
    };

    Capture.prototype.packets_out = function() {
      return this.packets.filter(function(packet) {
        return __indexOf.call(packet.transaction.packets_out, packet) >= 0;
      });
    };

    Capture.prototype.begin = function(bandwidth) {
      return packet_begin(this.packets[0], bandwidth);
    };

    Capture.prototype.end = function() {
      return this.packets[this.packets.length - 1].timestamp;
    };

    Capture.prototype.duration = function(bandwidth) {
      return this.end() - this.begin(bandwidth);
    };

    Capture.prototype.bandwidth = function() {
      var current_bandwidth, max_bandwidth, packets, window_begin, window_bytes, window_end, window_size, _i, _ref;
      packets = this.packets_in();
      window_size = 0.3;
      window_begin = 0;
      window_bytes = 0;
      max_bandwidth = 0;
      for (window_end = _i = 0, _ref = packets.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; window_end = 0 <= _ref ? ++_i : --_i) {
        window_bytes += packets[window_end].ethernet.byteLength;
        while (window_size < packets[window_end].timestamp - packets[window_begin].timestamp) {
          window_bytes -= packets[window_begin].ethernet.byteLength;
          window_begin += 1;
        }
        if (window_begin === 0) {
          continue;
        }
        current_bandwidth = window_bytes * 8 / window_size / 1000;
        if (current_bandwidth > max_bandwidth) {
          max_bandwidth = current_bandwidth;
        }
      }
      return Math.ceil(max_bandwidth);
    };

    return Capture;

  })();

  Stream = (function() {

    function Stream(capture, ab, ba, connection) {
      var add, inprogress, startnew,
        _this = this;
      this.capture = capture;
      this.src = {
        ip: connection.a.ip,
        port: connection.a.port,
        address: connection.a.ip + ':' + connection.a.port
      };
      this.dst = {
        ip: connection.b.ip,
        port: connection.b.port,
        address: connection.b.ip + ':' + connection.b.port
      };
      this.transactions = [];
      this.domain = void 0;
      inprogress = void 0;
      add = function() {
        var _ref;
        if ((_ref = _this.domain) == null) {
          _this.domain = inprogress.request.headers.host;
        }
        _this.transactions.push(inprogress);
        return inprogress.id = _this.capture.transactions.push(inprogress) - 1;
      };
      startnew = function() {
        return inprogress = new Transaction(_this, ab, ba, connection, add, startnew);
      };
      startnew();
    }

    return Stream;

  })();

  Transaction = (function() {
    var parse_headers;

    parse_headers = function(info) {
      var headers;
      headers = info.headers;
      info.headers = {};
      while (headers.length !== 0) {
        info.headers[headers.shift().toLowerCase()] = headers.shift();
      }
      return info;
    };

    Transaction.prototype.register_packet = function(connection, buffer, packet) {
      var _ref, _ref1;
      packet.transaction = this;
      this.packets.push(packet);
      if (packet.ipv4.src.toString() === connection.a.ip && packet.tcp.srcport === connection.a.port) {
        this.packets_out.push(packet);
        if (packet.tcp.payload.size > 0) {
          if ((_ref = this.request_first) == null) {
            this.request_first = packet;
          }
          return this.request_last = packet;
        }
      } else {
        this.packets_in.push(packet);
        if (packet.tcp.payload.size > 0) {
          if ((_ref1 = this.response_first) == null) {
            this.response_first = packet;
          }
          return this.response_last = packet;
        }
      }
    };

    function Transaction(stream, ab, ba, connection, onbegin, onend) {
      var req_parser, res_parser,
        _this = this;
      this.stream = stream;
      this.capture = this.stream.capture;
      req_parser = new HTTPParser(HTTPParser.REQUEST);
      res_parser = new HTTPParser(HTTPParser.RESPONSE);
      req_parser.onHeadersComplete = function(info) {
        if (_this.request != null) {
          return;
        }
        _this.request = parse_headers(info);
        return onbegin();
      };
      res_parser.onHeadersComplete = function(info) {
        _this.response = parse_headers(info);
        if (!('transfer-encoding' in _this.response.headers) && !('content-length' in _this.response.headers)) {
          return res_parser.onMessageComplete();
        }
      };
      this.packets = [];
      this.packets_in = [];
      this.packets_out = [];
      connection.on('data', this.register_packet.bind(this, connection));
      ab.on('data', function(dv) {
        return req_parser.execute(new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength), 0, dv.byteLength);
      });
      ba.on('data', function(dv) {
        return res_parser.execute(new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength), 0, dv.byteLength);
      });
      ab.on('end', function() {
        return req_parser.finish();
      });
      ba.on('end', function() {
        return res_parser.finish();
      });
      res_parser.onMessageComplete = function() {
        var _i, _j, _len, _len1, _ref, _ref1;
        _ref = [connection, ab, ba];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          stream = _ref[_i];
          stream.removeAllListeners('data');
        }
        _ref1 = [connection, ab, ba];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          stream = _ref1[_j];
          stream.removeAllListeners('end');
        }
        connection.on('data', function(buffer, packet) {
          var event, _k, _len2, _ref2;
          if (packet.tcp.payload.size === 0) {
            return _this.register_packet(connection, buffer, packet);
          } else {
            _ref2 = ['data', 'end'];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              event = _ref2[_k];
              connection.removeAllListeners(event);
            }
            onend();
            return connection.emit('data', buffer, packet);
          }
        });
        return connection.on('end', function() {
          var event, _k, _len2, _ref2;
          _ref2 = ['data', 'end'];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            event = _ref2[_k];
            connection.removeAllListeners(event);
          }
          return onend();
        });
      };
    }

    Transaction.prototype.begin = function(bandwidth) {
      return packet_begin(this.packets[0], bandwidth);
    };

    Transaction.prototype.end = function() {
      return packets[packets.length - 1].timestamp;
    };

    Transaction.prototype.request_begin = function(bandwidth) {
      return packet_begin(this.request_first, bandwidth);
    };

    Transaction.prototype.request_end = function() {
      return this.request_last.timestamp;
    };

    Transaction.prototype.request_duration = function(bandwidth) {
      return this.request_end() - this.request_begin(bandwidth);
    };

    Transaction.prototype.response_begin = function(bandwidth) {
      return packet_begin(this.response_first, bandwidth);
    };

    Transaction.prototype.response_end = function() {
      return this.response_last.timestamp;
    };

    Transaction.prototype.response_duration = function(bandwidth) {
      return this.response_end() - this.response_begin(bandwidth);
    };

    return Transaction;

  })();

}).call(this);
